int binarySearch(vector<int>& nums,int target){
  int left = 0;
  int right = nums.size()-1;
  while(left<=right){
    int mid = left + (right-left)/2; //avoid of overflow
    if(nums[mid]<target)
      left = mid+1;
    else
      right = mid-1;  //in case of nums[mid]>=target,when left > right,jump out of this loop and return left(now left=right+1) 
  }
  return left;
}

class solution{
public:
  vector<int> plusoOne(vector<int>& digits){
    int length = digits.size()-1;
    caryOrNot(digits,length);
    return digits;
  }
  
  void carryOrNot(vector<int>& nums,depth){
    if(nums[depth]==9){
      if(depth==0)  
        nums[depth]=0;
        nums.insert(nums.begin(),1);
      else
        nums[depth]=0;
        carryOrNot(nums,depth-1);
    }
    else
      digits[depth]+=1;  
  }
};
